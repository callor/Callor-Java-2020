package com.callor.varriable;

public class ByteVar {
	public static void main(String[] args) {
		byte val = 10;
		System.out.println(val);
		
		
		/*
		 * 0xF8 은 10진수로 248 이다.
		 * byte 형은 1바이트를 표현하기 때문에 
		 * 자바에서 -27 ~27-1 = -128 ~ 127 표현범위를 갖는다. 어... 248 출력못하겠네.
		 * 
		 * 127 까지 갔다고 치면 
		 * 248 - 128 (0 포함해서 127+1) = 120 => 120번 더 갈 수 있겠다.
		 * 
		 * byte형은 -128 부터 시작되기 때문에 -128 + 120 = -8
		 * 출력결과는 -8이다.
		 * 
		 */
		val = (byte)0xF8;
		System.out.println(val);
		
		
		/*
		 * 
		 * 자바는 기본 자료형 확산 변환될때 부호확장이 일어나서 상위비트를 부호값으로 채운다.
		 * 
		 * 왜 굳이 이렇게 까지 하는지 정말 모르겠지만, 이런경우는 있을 수 있을거 같다.
		 * 통신을 위해서 int형 값인 0xF8 을 바이트 나 바이트 배열로 전달하고,
		 * 그 값을 받는 곳에서 다시 int로 변환하는 중에 이런 문제가 생길 수 있겠다.
		 * 
		 * 
		 * 굳이 int 변환을 위해서는 int형 0xFF 를 비트 AND 연산  
		 * 적용해주면 부호와 값을 그대로 유지할 수 있다.
		 * 
		 * 32비트 0xFF = 00000000 00000000 00000000 11111111 와 
		 * 부호확장된 32비트 0xF8 = 11111111 11111111 11111111 11111000
		 * 비트 AND 연산하면
		 * 결과 = 00000000 00000000 00000000 111110002
		 * 
		 * 248 나왔다!!!!
		 */
		
		val = (byte)0xF8;
		int value = val & 0xFF;
		System.out.println(value);
		
	}

}
